<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <style>
      html {
        font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue",
          sans-serif;
        font-size: 20px;
      }
      body {
        margin: 0;
        padding: 0;
      }
      #parent {
        background-color: #dde;
        width: 100px;
        height: 100px;
      }
      #child {
        background-color: #aab;
        width: 50px;
        height: 50px;
        position: relative;
        top: 10px;
        left: 10px;
      }
      #parent[data-layout="true"] {
        width: 200px;
        height: 200px;
        position: relative;
        top: 100px;
        left: 100px;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import { patch } from "../index.js";
      import { after } from "../utils.js";
      import S from "https://cdn.skypack.dev/s-js";
      import { animate, mix } from "https://cdn.skypack.dev/popmotion";
      import {
        layoutNode,
        updateProjectionStyle,
      } from "https://cdn.skypack.dev/projection@2.0.0-alpha.3";
      import sync, { cancelSync } from "https://cdn.skypack.dev/framesync";

      function mixRect(prev, next, p) {
        return {
          top: mix(prev.top, next.top, p),
          left: mix(prev.left, next.left, p),
          right: mix(prev.right, next.right, p),
          bottom: mix(prev.bottom, next.bottom, p),
        };
      }

      function pixelsToPercent(pixels, axis) {
        return (pixels / (axis.max - axis.min)) * 100;
      }

      function correctBorderRadius(latest, node) {
        if (typeof latest === "string") {
          if (latest.endsWith("px")) {
            latest = parseFloat(latest);
          } else {
            return latest;
          }
        }
        const { x, y } = node.getTarget();
        return `${pixelsToPercent(latest, x)}% ${pixelsToPercent(latest, y)}%`;
      }

      function animateRect(stream, options = {}) {
        const result = S.data(S.sample(stream));
        S((prev) => {
          if (prev && stream()) {
            animate({
              ...options,
              from: 0,
              to: 1,
              onUpdate: (p) => void result(mixRect(prev, stream(), p)),
            });
          }
          return stream();
        }, S.sample(stream));
        return result;
      }

      const Projected = ({
        rect,
        parent,
        updateLayout,
        children,
        layout,
        borderRadius = 0,
        ...other
      }) => {
        const element = S.data();
        const projection = S(() => {
          if (element()) {
            const projection = layoutNode(
              {
                onProjectionUpdate: () =>
                  updateProjectionStyle(element(), projection),
              },
              typeof parent === "function" ? parent() : undefined
            );
            S.cleanup(() => {
              projection.destroy();
            });
            S.on(updateLayout, () => {
              element().style.transform = "";
              const nextLayout = element().getBoundingClientRect();
              projection.setLayout(nextLayout);
              layout(nextLayout);
            });
            S(() => {
              const target = rect() || layout();
              if (target) {
                projection.setTarget(target);
              }
              element().style.borderRadius = correctBorderRadius(
                borderRadius,
                projection
              );
            });
            return projection;
          }
        });
        return {
          ...other,
          ref: element,
          children:
            typeof children === "function" ? children(projection) : children,
        };
      };

      S.root(() => {
        const toggle = S.data();
        const parentLayout = S.data();
        const childLayout = S.data();
        const parentRect = animateRect(parentLayout);
        const childRect = animateRect(childLayout);

        const Main = Projected({
          id: "parent",
          rect: parentRect,
          layout: parentLayout,
          updateLayout: toggle,
          borderRadius: 16,
          "data-layout": toggle,
          onClick: () => toggle(!S.sample(toggle)),
          children: (parent) =>
            Projected({
              parent,
              borderRadius: 16,
              rect: childRect,
              layout: childLayout,
              updateLayout: toggle,
              id: "child",
            }),
        });

        patch(document.body, Main);
      });
    </script>
  </body>
</html>
